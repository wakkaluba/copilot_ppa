"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.VulnerabilityService = void 0;
const logger_1 = require("../../utils/logger");
const child_process_1 = require("child_process");
class VulnerabilityService {
    logger;
    vulnerabilityCache = new Map();
    cacheDuration = 1000 * 60 * 60; // 1 hour
    constructor() {
        this.logger = logger_1.Logger.getInstance();
    }
    async checkNpmVulnerabilities(packageName, version) {
        try {
            const cacheKey = `npm:${packageName}@${version}`;
            const cached = this.getCachedVulnerabilities(cacheKey);
            if (cached)
                return cached;
            const result = (0, child_process_1.execSync)(`npm audit --json ${packageName}@${version}`, { encoding: 'utf8' });
            const vulns = this.parseNpmAuditResult(JSON.parse(result));
            this.cacheVulnerabilities(cacheKey, vulns);
            return vulns;
        }
        catch (error) {
            this.logger.error('Error checking npm vulnerabilities', error);
            return [];
        }
    }
    async checkPythonVulnerabilities(packageName, version) {
        try {
            const cacheKey = `python:${packageName}@${version}`;
            const cached = this.getCachedVulnerabilities(cacheKey);
            if (cached)
                return cached;
            const result = (0, child_process_1.execSync)(`safety check ${packageName}==${version} --json`, { encoding: 'utf8' });
            const vulns = this.parseSafetyCheckResult(JSON.parse(result));
            this.cacheVulnerabilities(cacheKey, vulns);
            return vulns;
        }
        catch (error) {
            this.logger.error('Error checking Python vulnerabilities', error);
            return [];
        }
    }
    getCachedVulnerabilities(key) {
        const cached = this.vulnerabilityCache.get(key);
        if (!cached || Date.now() - cached[0].timestamp > this.cacheDuration) {
            return undefined;
        }
        return cached;
    }
    cacheVulnerabilities(key, vulnerabilities) {
        this.vulnerabilityCache.set(key, vulnerabilities.map(v => ({
            ...v,
            timestamp: Date.now()
        })));
    }
    parseNpmAuditResult(result) {
        const vulns = [];
        for (const [id, advisory] of Object.entries(result.advisories || {})) {
            vulns.push({
                id: id,
                title: advisory.title,
                description: advisory.overview,
                severity: advisory.severity,
                fixedIn: advisory.patched_versions,
                references: advisory.references,
                timestamp: Date.now()
            });
        }
        return vulns;
    }
    parseSafetyCheckResult(result) {
        return result.map((vuln) => ({
            id: vuln.vulnerability_id,
            title: vuln.advisory,
            description: vuln.details,
            severity: this.mapPythonSeverity(vuln.severity),
            fixedIn: vuln.fixed_version,
            references: [vuln.more_info_url],
            timestamp: Date.now()
        }));
    }
    mapPythonSeverity(severity) {
        switch (severity.toLowerCase()) {
            case 'critical': return 'critical';
            case 'high': return 'high';
            case 'moderate':
            case 'medium': return 'medium';
            default: return 'low';
        }
    }
}
exports.VulnerabilityService = VulnerabilityService;
//# sourceMappingURL=VulnerabilityService.js.map