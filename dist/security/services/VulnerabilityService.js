"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.VulnerabilityService = void 0;
const logger_1 = require("../../utils/logger");
const child_process_1 = require("child_process");
class VulnerabilityService {
    logger;
    vulnerabilityCache = new Map();
    detailsCache = new Map();
    cacheDuration = 1000 * 60 * 60; // 1 hour
    constructor() {
        this.logger = logger_1.Logger.getInstance();
    }
    async checkNpmVulnerabilities(packageName, version) {
        try {
            const cacheKey = `npm:${packageName}@${version}`;
            const cached = this.getCachedVulnerabilities(cacheKey);
            if (cached) {
                return cached;
            }
            const result = (0, child_process_1.execSync)(`npm audit --json ${packageName}@${version}`, { encoding: 'utf8' });
            const vulns = this.parseNpmAuditResult(JSON.parse(result));
            this.cacheVulnerabilities(cacheKey, vulns);
            // Also cache individual vulnerabilities for later lookup
            vulns.forEach(vuln => {
                this.detailsCache.set(vuln.id, vuln);
            });
            return vulns;
        }
        catch (error) {
            this.logger.error('Error checking npm vulnerabilities', error);
            return [];
        }
    }
    async checkPythonVulnerabilities(packageName, version) {
        try {
            const cacheKey = `python:${packageName}@${version}`;
            const cached = this.getCachedVulnerabilities(cacheKey);
            if (cached) {
                return cached;
            }
            const result = (0, child_process_1.execSync)(`safety check ${packageName}==${version} --json`, { encoding: 'utf8' });
            const vulns = this.parseSafetyCheckResult(JSON.parse(result));
            this.cacheVulnerabilities(cacheKey, vulns);
            // Also cache individual vulnerabilities for later lookup
            vulns.forEach(vuln => {
                this.detailsCache.set(vuln.id, vuln);
            });
            return vulns;
        }
        catch (error) {
            this.logger.error('Error checking Python vulnerabilities', error);
            return [];
        }
    }
    /**
     * Get detailed information about a specific vulnerability
     * @param vulnId The ID of the vulnerability to retrieve details for
     * @returns Detailed vulnerability information, or undefined if not found
     */
    async getVulnerabilityDetails(vulnId) {
        try {
            // Check in our cache first
            if (this.detailsCache.has(vulnId)) {
                return this.detailsCache.get(vulnId);
            }
            // Otherwise, fetch from the National Vulnerability Database or other source
            // This is a placeholder implementation - in a real-world scenario, you would
            // query the NVD API or other vulnerability databases
            const externalDetails = await this.fetchVulnerabilityDetails(vulnId);
            if (externalDetails) {
                this.detailsCache.set(vulnId, externalDetails);
                return externalDetails;
            }
            return undefined;
        }
        catch (error) {
            this.logger.error(`Error getting vulnerability details for ${vulnId}`, error);
            return undefined;
        }
    }
    async fetchVulnerabilityDetails(vulnId) {
        // In a real implementation, this would fetch from NVD or similar service
        // For now, return a placeholder
        if (vulnId) {
            return {
                id: vulnId,
                title: `Vulnerability ${vulnId}`,
                description: 'Detailed information would be fetched from a vulnerability database.',
                severity: 'medium',
                fixedIn: 'latest',
                references: [`https://nvd.nist.gov/vuln/detail/${vulnId}`],
                timestamp: new Date()
            };
        }
        return undefined;
    }
    getCachedVulnerabilities(key) {
        const cached = this.vulnerabilityCache.get(key);
        if (!cached || Date.now() - cached[0].timestamp > this.cacheDuration) {
            return undefined;
        }
        return cached;
    }
    cacheVulnerabilities(key, vulnerabilities) {
        this.vulnerabilityCache.set(key, vulnerabilities.map(v => ({
            ...v,
            timestamp: new Date()
        })));
    }
    parseNpmAuditResult(result) {
        const vulns = [];
        for (const [id, advisory] of Object.entries(result.advisories || {})) {
            vulns.push({
                id: id,
                title: advisory.title,
                description: advisory.overview,
                severity: advisory.severity,
                fixedIn: advisory.patched_versions,
                references: advisory.references,
                timestamp: new Date()
            });
        }
        return vulns;
    }
    parseSafetyCheckResult(result) {
        return result.map((vuln) => ({
            id: vuln.vulnerability_id,
            title: vuln.advisory,
            description: vuln.details,
            severity: this.mapPythonSeverity(vuln.severity),
            fixedIn: vuln.fixed_version,
            references: [vuln.more_info_url],
            timestamp: new Date()
        }));
    }
    mapPythonSeverity(severity) {
        switch (severity.toLowerCase()) {
            case 'critical': return 'critical';
            case 'high': return 'high';
            case 'moderate':
            case 'medium': return 'medium';
            default: return 'low';
        }
    }
}
exports.VulnerabilityService = VulnerabilityService;
//# sourceMappingURL=VulnerabilityService.js.map