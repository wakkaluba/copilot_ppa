import * as vscode from 'vscode';
import { VulnerabilityInfo } from '../types';
import { Logger } from '../../utils/logger';
import { execSync } from 'child_process';

export class VulnerabilityService {
    private readonly logger: Logger;
    private readonly vulnerabilityCache = new Map<string, VulnerabilityInfo[]>();
    private readonly cacheDuration = 1000 * 60 * 60; // 1 hour

    constructor() {
        this.logger = Logger.getInstance();
    }

    public async checkNpmVulnerabilities(packageName: string, version: string): Promise<VulnerabilityInfo[]> {
        try {
            const cacheKey = `npm:${packageName}@${version}`;
            const cached = this.getCachedVulnerabilities(cacheKey);
            if (cached) return cached;

            const result = execSync(`npm audit --json ${packageName}@${version}`, { encoding: 'utf8' });
            const vulns = this.parseNpmAuditResult(JSON.parse(result));
            this.cacheVulnerabilities(cacheKey, vulns);
            return vulns;
        } catch (error) {
            this.logger.error('Error checking npm vulnerabilities', error);
            return [];
        }
    }

    public async checkPythonVulnerabilities(packageName: string, version: string): Promise<VulnerabilityInfo[]> {
        try {
            const cacheKey = `python:${packageName}@${version}`;
            const cached = this.getCachedVulnerabilities(cacheKey);
            if (cached) return cached;

            const result = execSync(`safety check ${packageName}==${version} --json`, { encoding: 'utf8' });
            const vulns = this.parseSafetyCheckResult(JSON.parse(result));
            this.cacheVulnerabilities(cacheKey, vulns);
            return vulns;
        } catch (error) {
            this.logger.error('Error checking Python vulnerabilities', error);
            return [];
        }
    }

    private getCachedVulnerabilities(key: string): VulnerabilityInfo[] | undefined {
        const cached = this.vulnerabilityCache.get(key);
        if (!cached || Date.now() - cached[0].timestamp > this.cacheDuration) {
            return undefined;
        }
        return cached;
    }

    private cacheVulnerabilities(key: string, vulnerabilities: VulnerabilityInfo[]): void {
        this.vulnerabilityCache.set(key, vulnerabilities.map(v => ({
            ...v,
            timestamp: Date.now()
        })));
    }

    private parseNpmAuditResult(result: any): VulnerabilityInfo[] {
        const vulns: VulnerabilityInfo[] = [];
        for (const [id, advisory] of Object.entries<any>(result.advisories || {})) {
            vulns.push({
                id: id,
                title: advisory.title,
                description: advisory.overview,
                severity: advisory.severity,
                fixedIn: advisory.patched_versions,
                references: advisory.references,
                timestamp: Date.now()
            });
        }
        return vulns;
    }

    private parseSafetyCheckResult(result: any): VulnerabilityInfo[] {
        return result.map((vuln: any) => ({
            id: vuln.vulnerability_id,
            title: vuln.advisory,
            description: vuln.details,
            severity: this.mapPythonSeverity(vuln.severity),
            fixedIn: vuln.fixed_version,
            references: [vuln.more_info_url],
            timestamp: Date.now()
        }));
    }

    private mapPythonSeverity(severity: string): string {
        switch (severity.toLowerCase()) {
            case 'critical': return 'critical';
            case 'high': return 'high';
            case 'moderate':
            case 'medium': return 'medium';
            default: return 'low';
        }
    }
}
