import * as vscode from 'vscode';
import { VulnerabilityInfo } from '../types';
import { Logger } from '../../utils/logger';
import { execSync } from 'child_process';

export class VulnerabilityService {
    private readonly logger: Logger;
    private readonly vulnerabilityCache = new Map<string, VulnerabilityInfo[]>();
    private readonly detailsCache = new Map<string, VulnerabilityInfo>();
    private readonly cacheDuration = 1000 * 60 * 60; // 1 hour

    constructor() {
        this.logger = Logger.getInstance();
    }

    public async checkNpmVulnerabilities(packageName: string, version: string): Promise<VulnerabilityInfo[]> {
        try {
            const cacheKey = `npm:${packageName}@${version}`;
            const cached = this.getCachedVulnerabilities(cacheKey);
            if (cached) {return cached;}

            const result = execSync(`npm audit --json ${packageName}@${version}`, { encoding: 'utf8' });
            const vulns = this.parseNpmAuditResult(JSON.parse(result));
            this.cacheVulnerabilities(cacheKey, vulns);
            
            // Also cache individual vulnerabilities for later lookup
            vulns.forEach(vuln => {
                this.detailsCache.set(vuln.id, vuln);
            });
            
            return vulns;
        } catch (error) {
            this.logger.error('Error checking npm vulnerabilities', error);
            return [];
        }
    }

    public async checkPythonVulnerabilities(packageName: string, version: string): Promise<VulnerabilityInfo[]> {
        try {
            const cacheKey = `python:${packageName}@${version}`;
            const cached = this.getCachedVulnerabilities(cacheKey);
            if (cached) {return cached;}

            const result = execSync(`safety check ${packageName}==${version} --json`, { encoding: 'utf8' });
            const vulns = this.parseSafetyCheckResult(JSON.parse(result));
            this.cacheVulnerabilities(cacheKey, vulns);
            
            // Also cache individual vulnerabilities for later lookup
            vulns.forEach(vuln => {
                this.detailsCache.set(vuln.id, vuln);
            });
            
            return vulns;
        } catch (error) {
            this.logger.error('Error checking Python vulnerabilities', error);
            return [];
        }
    }

    /**
     * Get detailed information about a specific vulnerability
     * @param vulnId The ID of the vulnerability to retrieve details for
     * @returns Detailed vulnerability information, or undefined if not found
     */
    public async getVulnerabilityDetails(vulnId: string): Promise<VulnerabilityInfo | undefined> {
        try {
            // Check in our cache first
            if (this.detailsCache.has(vulnId)) {
                return this.detailsCache.get(vulnId);
            }

            // Otherwise, fetch from the National Vulnerability Database or other source
            // This is a placeholder implementation - in a real-world scenario, you would
            // query the NVD API or other vulnerability databases
            const externalDetails = await this.fetchVulnerabilityDetails(vulnId);
            
            if (externalDetails) {
                this.detailsCache.set(vulnId, externalDetails);
                return externalDetails;
            }
            
            return undefined;
        } catch (error) {
            this.logger.error(`Error getting vulnerability details for ${vulnId}`, error);
            return undefined;
        }
    }

    private async fetchVulnerabilityDetails(vulnId: string): Promise<VulnerabilityInfo | undefined> {
        // In a real implementation, this would fetch from NVD or similar service
        // For now, return a placeholder
        if (vulnId) {
            return {
                id: vulnId,
                title: `Vulnerability ${vulnId}`,
                description: 'Detailed information would be fetched from a vulnerability database.',
                severity: 'medium',
                fixedIn: 'latest',
                references: [`https://nvd.nist.gov/vuln/detail/${vulnId}`],
                timestamp: Date.now()
            };
        }
        return undefined;
    }

    private getCachedVulnerabilities(key: string): VulnerabilityInfo[] | undefined {
        const cached = this.vulnerabilityCache.get(key);
        if (!cached || Date.now() - cached[0].timestamp > this.cacheDuration) {
            return undefined;
        }
        return cached;
    }

    private cacheVulnerabilities(key: string, vulnerabilities: VulnerabilityInfo[]): void {
        this.vulnerabilityCache.set(key, vulnerabilities.map(v => ({
            ...v,
            timestamp: Date.now()
        })));
    }

    private parseNpmAuditResult(result: any): VulnerabilityInfo[] {
        const vulns: VulnerabilityInfo[] = [];
        for (const [id, advisory] of Object.entries<any>(result.advisories || {})) {
            vulns.push({
                id: id,
                title: advisory.title,
                description: advisory.overview,
                severity: advisory.severity,
                fixedIn: advisory.patched_versions,
                references: advisory.references,
                timestamp: Date.now()
            });
        }
        return vulns;
    }

    private parseSafetyCheckResult(result: any): VulnerabilityInfo[] {
        return result.map((vuln: any) => ({
            id: vuln.vulnerability_id,
            title: vuln.advisory,
            description: vuln.details,
            severity: this.mapPythonSeverity(vuln.severity),
            fixedIn: vuln.fixed_version,
            references: [vuln.more_info_url],
            timestamp: Date.now()
        }));
    }

    private mapPythonSeverity(severity: string): string {
        switch (severity.toLowerCase()) {
            case 'critical': return 'critical';
            case 'high': return 'high';
            case 'moderate':
            case 'medium': return 'medium';
            default: return 'low';
        }
    }
}
